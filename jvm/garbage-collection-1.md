# garbage-collection-1

## 서론
여러분이 자바 혹은 코틀린을 사용하는 개발자라면, 한 번쯤은 생각해봤을 것입니다. '인스턴스를 막 만들고, 해제하지도 않는데 왜 메모리는 멀쩡하지?'
보이지 않는 곳에서는 우리의 GC가 열심히 일하고 있거든요. 개인적으로는 GC에 대해서는 알고 있어야 어디가서 자바(코틀린) 개발좀 한다 소리는 할 수 있을 것 같네요.

이번 ```GC 부수기 1장에서는``` 아래와 같은 항목을 배우면서 파헤쳐보도록 하겠습니다.
- JVM Memory 구조
- 자료구조 Heap에 대하여
- GC란 무엇인가

---
## JVM Memory 구조
Java(Kotlin)이 운영체제에 상관없이 컴파일이 가능한 이유는, 운영체제에 독립적인 JVM의 존재덕분입니다. 근데, JVM에도 메모리 구조가 있다는 거 알고 계셨죠?

![image](https://github.com/user-attachments/assets/1414b842-7f1e-4689-99cd-c5544a4d36ba)

JVM의 구조를 잘 설명한 자료가 있어 가져왔습니다. ([출처](https://inpa.tistory.com/entry/JAVA-%E2%98%95-JVM-%EB%82%B4%EB%B6%80-%EA%B5%AC%EC%A1%B0-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%98%81%EC%97%AD-%EC%8B%AC%ED%99%94%ED%8E%B8))

<img width="795" alt="스크린샷 2024-08-19 오후 11 15 43" src="https://github.com/user-attachments/assets/9afd016b-b88e-4746-84f4-ff797205684c">

JVM은 크게 5가지 영역으로 나뉩니다. ```클래스 로더```, ```실행 엔진```, ```Runtime Data Area```, ```JNI```, ```Native Method Lib```
여기서 자세하게 살펴보아야 할 것은 ```Runtime Data Area```, 런타임 데이터 영역입니다. 말 그대로 런타임에서 사용하는 데이터를 모아두는 공간입니다. 해당 영역은 또다시 5개의 영역으로 구별됩니다.

### Method Area
클래스 프로퍼티의 정보(이름, 타입, 접근 제어자 등), 메소드 정보(이름, 반환형, 파라미터, 접근 제어자 등), static 변수 등을 저장하는 영역입니다.

### Heap
인스턴스가 생기는 영역입니다. 자바에서는 ```new``` 키워드로 생성된 객체가 이곳에 생성됩니다.

### Stack
지역변수, 파라미터, 리턴 값, 연산 중 발생하는 데이터를 임시로 저장하는 영역입니다. 

### PC Register
스레드가 실행되는 곳의 주소, 명령을 저장하는 영역입니다.

### Native Method Stack Area
C/C++ 등의 다른 언어로 작성된 코드를 수행하기 위한 영역입니다.


보통은 ```Method Area```, ```Heap```을 중점적으로 설명합니다. 그 이유는 이 둘만이 애플리케이션 내에서 모든 스레드가 공유하는 영역이기 때문입니다.

---

## 자료구조 Heap에 대하여
지금까지 우리는 JVM의 메모리 영역에 대해서 간략하게 알아보았습니다. 자세히 알고 싶다면 개인적으로 찾아보는 것을 추천합니다.

> 힙은 완전 이진 트리 형태로 데이터를 저장하며, 우선순위 큐를 위하여 만들어진 자료구조이다. 반정렬 상태를 유지한다.

```완전 이진 트리``` : 트리의 모든 레벨이 완전히 채워져 있어야 한다.(최하위 레벨은 예외) 마지막 레벨의 노드는 가능한 한 왼쪽부터 차례대로 채워져 있어야 한다.

```우선순위 큐``` : 우선순위에 따라 요소가 처리되는 자료구조

```반정렬 상태``` : 부분적으로 정렬된 상태를 유지한다. 최대 힙에서는 부모 노드가 자식 노드보다 크거나 같고, 최소 힙에서는 부모 노드가 자식 노드보다 작거나 같다.

          50
         /  \
       30    20
      /  \   / \
    10   5  15  8
최대 힙을 예시로 보면, 자식 노드 사이에는 크기 순서가 정해지지 않았습니다. 부모-자식 간의 크기 관계만 유지합니다. 따라서 반정렬 상태라고 표현되는 것입니다.
반정렬 상태 덕분에 힙이 효율적으로 동작할 수 있는데, ```삽입```/```삭제``` 연산은 반정렬 상태를 유지하며, 특정 노드에 대한 위치를 빠르게 조정하고 트리의 구조를 크게 변화시키지 있도록 합니다.

```O(log n)```의 시간 복잡도를 갖게되는데, 이게 얼마나 빠르냐면...
### 배열(리스트)에서의 정렬을 유지하며 삽입
```length = 1,000,000```인 정렬된 배열에 새로운 요소를 삽입할 때, 최악의 경우는 ```1,000,000```개의 요소를 모두 탐색해야 합니다.

### 힙에서의 정렬을 유지하며 삽입
```length = 1,000,000```인 정렬된 힙에 새로운 요소를 삽입할 때, ```log(1,000,000) = 20``` 번의 비교만을 수행하여 삽입합니다.

---

## GC(Garbage Collection)란 무엇인가
```C
arr = (int*)malloc(sizeof(int) * 4);

...

free(arr)
```
C언어에서 메모리를 동적으로 할당하고, 해제하는 방법입니다. 그런데 엄청나게 복잡한 서비스를 만드는 시대에서 언제 메모리를 하나하나 해제하고 있을까요? 심지어 깜빡하고 메모리를 해제하지 않으면 어마어마한 메모리 릭을 마주하겠죠.

그래서 C언어같이 기계어에 가까운 언어 말고, Java, C#, Python등과 같은 사용자에게 가까운 고수준 언어에서는 GC라는 개념을 채택하고 있습니다.

> 더이상 사용하지 않는 객체, 메모리 공간을 자동으로 식별하고 회수하여 메모리 누수를 방지하고, 메모리를 효율적으로 관리한다.

### GC의 기본 메커니즘
- 메모리 할당 : 새로운 인스턴스는 힙 영역에 저장된다. 저장된 메모리 공간은 프로그램이 해당 인스턴스를 참조하는 동안 계속해서 유지된다.
- 메모리 해제 : 인스턴스가 참조되지 않는다면, 해당 메모리 공간을 해제한다.

GC는 실행 조건이 일정하지 않습니다. ```System.gc()```로 직접 호출하더라도 그 즉시 GC가 작동하는지 알 수 없습니다.
