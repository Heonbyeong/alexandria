# 선형 자료구조

### Array(배열)

> 연속된 메모리 공간에 같은 타입의 데이터를 순서대로 저장하는 구조

![배열](https://github.com/user-attachments/assets/fdd4bd54-9571-40b6-9ae4-a1e062d995c4)

**특징**

- 배열에 포함된 원소는 인덱스가 붙음
- 각 원소는 인덱스로 접근할 수 있고, 이 경우 O(1)으로 원소를 찾을 수 있음
- 배열의 크기는 고정되어 있음
- 중간 위치에 원소를 삽입/삭제하는 경우 O(n)이 소요

**장점**

- 인덱스 기반 탐색이 O(1)이기 때문에 탐색이 많은 경우 사용하면 좋음
- 연속된 메모리 공간을 사용하므로 오버헤드가 적어 효율성이 좋음 (캐시 지역성이 높음)

**단점**

- 배열의 크기를 동적으로 변경할 수 없음
- 연속된 메모리 공간에 데이터가 존재해야 하므로 삽입/삭제가 빈번한 경우 효율이 떨어짐

---

### Linked List(연결리스트)

> 각 노드(Node)가 데이터와 다음 노드를 가리키는 포인터로 구성된 자료구조
> 

![연결리스트](https://github.com/user-attachments/assets/5ab3db03-39de-4ae2-9498-782d43a21884)

**특징**

- 동적으로 크기 조절이 가능함
- 분산된 메모리 공간에 데이터를 저장
- 탐색은 O(n)이 소요 (포인터를 따라 순차적으로 이동해야 하기 때문)
- 원소의 삽입/삭제는 O(1)이 소요
- Head(첫 번째 노드를 가리키는 포인터), Tail(마지막 노드를 가리키는 포인터) 존재

**장점**

- 삽입/삭제가 빈번한 경우 사용하면 좋음
- 연속된 메모리 공간이 필요하지 않아 동적으로 크기를 변경할 수 있으며 효율적으로 사용할 수 있음

**단점**

- 접근 속도가 느려 탐색이 빈번한 경우 비효율적
- 데이터와 포인터를 저장할 공간이 필요하여 메모리 오버헤드 발생
- 노드가 분산되어 있어 캐시 지역성이 떨어짐

**Singly Linked List(단일 연결리스트)**

- 각 노드가 데이터와 다음 노드를 가리키는 포인터 하나만 가지는 기본적인 연결리스트
- 한 방향으로만 순회 가능 (역방향 탐색 불가능)
- 메모리 사용량이 적음

**Doubly Linked List(이중 연결리스트)**

- 각 노드가 데이터, 이전 노드 포인터, 다음 노드 포인터를 가지는 양방향 연결리스트
- 양방향 순회가 가능
- 포인터가 하나 더 필요하여 메모리 사용량이 증가

**Circular Linked List(원형 연결리스트)**

- 마지막 노드가 첫 번째 노드를 가리켜 원형 구조를 만듦 (Tail → Head로 연결)
- 끝이 없어, 순환적인 데이터 처리에 유용
- 순회/삭제/삽입과 같은 상황에서의 포인터 조작을 신경써야함

---

### Stack(스택)

> LIFO(**L**ast **I**n **F**irst **O**ut)으로 동작하는 자료구조
> 

![스택](https://github.com/user-attachments/assets/cbce4623-3b87-4000-b063-04cc30ce415f)

**특징**

- push - 스택의 맨 위에 원소를 추가하는 연산
- pop - 스택의 맨 위의 원소를 제거하면서 반환하는 연산
- peek - 스택의 맨 위 원소를 제거하지 않고 조회만 하는 연산
- 모든 연산은 O(1)의 시간복잡도를 가짐
- 접근할 수 있는 데이터는 맨 위 원소로 제한되어 있음
- 배열이나 연결리스트로 구현할 수 있음 (배열은 top인덱스를 유지, 연결리스트는 head를 top으로 사용)

**장점**

- 항상 top에서만 작업하기 때문에 연산이 빠르고 효율적임
- 필요한 만큼만 메모리를 사용하기 때문에 메모리 오버헤드가 적음

**단점**

- top 원소만 접근할 수 있어서 탐색에는 적합하지 않음
- LIFO 특성으로 인해 먼저 들어간 데이터를 처리하는 상황에는 사용할 수 없음

---

### Queue(큐)

> FIFO (**F**irst **I**n **F**irst **O**ut) 원칙으로 동작하는 자료구조
> 

![큐](https://github.com/user-attachments/assets/332cc348-7fbd-487e-8b93-f041f917a091)

**특징**

- enqueue - 큐의 뒤쪽(rear)에 원소를 추가하는 연산
- dequeue - 큐의 앞쪽(front)에 원소를 제거하며 반환하는 연산
- front - 큐의 맨 앞 원소를 조회, rear - 큐의 맨 뒤 원소를 조회
- 모든 연산은 O(1)의 시간복잡도를 가짐
- 배열이나 연결리스트로 구현할 수 있음 (배열은 front, rear 인덱스 유지, 연결리스트는 head를 front, tail을 rear로 사용)

**장점**

- FIFO 특성으로 처리 순서를 보장함
- 정해진 위치(front, rear)에서 연산이 일어나기 때문에 연산이 빠르고 효율적임
- 버퍼링, 스트리밍 같은 연속적인 데이터 처리에 적합

**단점**

- front, rear만 접근할 수 있어 탐색에는 적합하지 않음
- 배열로 구현하면 앞쪽 공간이 비어도 재사용하지 못해 메모리가 낭비됨 (원소를 당기는 작업을 하면 O(n)의 시간복잡도 소요)

**Linear Queue(선형 큐)**

- front, rear 인덱스를 사용해 구현하는 일반적인 큐
- enqueue시 rear 증가, dequeue시 front가 증가하는 방식으로 동작
- dequeue를 반복하면 앞쪽 공간을 사용할 수 없어 메모리가 누수된다는 문제가 있음

**Circular Queue(원형 큐)**

- 논리적으로 원형으로 연결된 것처럼 사용하는 큐
- 인덱스가 배열 크기에 도달하면 0으로 돌아가 빈 공간을 재사용하여 효율적 (모듈로 연산을 사용하여 구현)
- 큐가 비어있는 상태와 가득 찬 상태를 구분할 수 없어 별도의 작업 필요 (한 자리를 비워두거나 카운터 변수 사용)

---

### Deque(Double Ended Queue, 데크)

> 양쪽 끝에서 삽입과 삭제가 모두 가능한 자료구조
> 

![데크](https://github.com/user-attachments/assets/050ccf4a-d913-4580-862c-0f9048532ae6)

**특징**

- 스택과 큐의 특징을 모두 가지고 있는 양방향 큐 (한쪽 끝에서만 사용하면 스택, 양쪽 끝을 사용하면 큐)
- addFirst, offerFirst / removeFirst, pollFirst - 앞쪽에 원소를 추가/삭제하는 연산
- addLast, offerLast / removeLast, pollLast - 뒤쪽에 원소를 추가/삭제하는 연산
- 모든 연산은 O(1)의 시간복잡도를 가짐

**장점**

- 양쪽 끝에서의 삽입/삭제 연산이 빠름
- 슬라이딩 윈도우, 양방향 탐색 등 특정 알고리즘에서 효율이 높음

**단점**

- 중간 위치의 원소에는 직접 접근할 수 없어 탐색에는 비효율적
- 구현이 복잡함
